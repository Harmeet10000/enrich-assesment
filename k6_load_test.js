// k6_load_test.js
// Load test script for the API Gateway using k6.
// Simulates a mix of POST /jobs and GET /jobs/:requestId requests.

import http from 'k6/http';
import { check, sleep } from 'k6';
import { SharedArray } from 'k6/data';
import { vu } from 'k6/execution';
import { logger } from './src/utils/logger';

// Base URL of your API Gateway
const BASE_URL = 'http://localhost:3000';

// Data for POST requests (pre-defined payloads)
const postPayloads = new SharedArray('postPayloads', function () {
  return [
    { vendorType: 'sync', vendorPayload: { productId: 'PROD-001', quantity: 5 } },
    { vendorType: 'async', vendorPayload: { userId: 'USER-ABC', action: 'generate_report' } },
    { vendorType: 'sync', vendorPayload: { itemId: 'ITEM-XYZ', location: 'warehouse_A' } },
    { vendorType: 'async', vendorPayload: { customerId: 'CUST-999', event: 'process_order' } },
    { vendorType: 'sync', vendorPayload: { query: 'latest_news', category: 'tech' } }
  ];
});

// Store request IDs for polling (in a real scenario, this would be more robust,
// perhaps reading from a shared queue or database of known job IDs)
const createdRequestIds = new SharedArray('createdRequestIds', function () {
  return []; // This will be populated during the test
});

export const options = {
  // Define scenarios for the load test
  scenarios: {
    mixed_workload: {
      executor: 'constant-vus', // Maintain a constant number of virtual users
      vus: 200, // 200 concurrent virtual users
      duration: '60s', // Run for 60 seconds
      gracefulStop: '5s', // Give VUs 5 seconds to finish current iterations
      exec: 'runMixedWorkload' // Function to execute for each VU
    }
  },
  // Define thresholds for success/failure criteria
  thresholds: {
    http_req_duration: ['p(95)<1000', 'p(99)<2000'], // 95% of requests < 1s, 99% < 2s
    http_req_failed: ['rate<0.01'], // Less than 1% of requests should fail (HTTP errors)
    'checks{name:POST /jobs status is 202}': ['rate>0.99'], // 99% of POSTs should return 202
    'checks{name:GET /jobs/{request_id} status is 200 or 404}': ['rate>0.99'] // 99% of GETs should return 200/404
  }
};

/**
 * Helper function to generate a simple UUID (for mock GET requests if no real ID is available).
 * In a real test, you'd want to poll actual IDs generated by POST requests.
 */
function generateSimpleUuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (Math.random() * 16) | 0,
      v = c == 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/**
 * Main function for the mixed workload scenario.
 * Each virtual user will run this function repeatedly.
 */
export function runMixedWorkload() {
  // Mix of POST and GET requests: ~30% POST, ~70% GET
  if (Math.random() < 0.3) {
    // --- Perform POST /jobs request ---
    const payloadIndex = vu.idInTest % postPayloads.length;
    const payload = postPayloads[payloadIndex];

    const postRes = http.post(`${BASE_URL}/jobs`, JSON.stringify(payload), {
      headers: { 'Content-Type': 'application/json' },
      tags: { name: 'POST /jobs' } // Tag for k6 metrics
    });

    check(postRes, {
      'POST /jobs status is 202': (r) => r.status === 202,
      'POST /jobs response has request_id': (r) => r.json() && r.json().request_id !== undefined
    });

    if (postRes.status === 202 && postRes.json() && postRes.json().request_id) {
      const requestId = postRes.json().request_id;
      // Add the created request ID to a shared array for later polling
      // Note: SharedArray is read-only during execution, so this won't work directly.
      // For actual polling of dynamically created IDs, you'd typically need
      // a custom k6 extension or a separate "setup" function to pre-populate IDs,
      // or have a mechanism to fetch recent IDs from your system under test.
      // For this example, we'll simulate polling, but acknowledge this limitation.
      // A more realistic approach would be to poll the *same* request_id that was just created.
      pollJobStatus(requestId);
    }
  } else {
    // --- Perform GET /jobs/:requestId request ---
    // In a real scenario, you'd get a real requestId from a pool of previously created jobs.
    // For simplicity, we'll either poll a recently created ID (if available) or a random one.
    let requestIdToPoll;
    if (createdRequestIds.length > 0) {
      requestIdToPoll = createdRequestIds[Math.floor(Math.random() * createdRequestIds.length)];
    } else {
      requestIdToPoll = generateSimpleUuid(); // Fallback if no IDs are populated
    }
    pollJobStatus(requestIdToPoll);
  }

  sleep(1); // Simulate user think time (1 second pause between iterations)
}

/**
 * Function to poll the status of a job.
 * @param {string} requestId - The ID of the job to poll.
 */
function pollJobStatus(requestId) {
  let jobStatus = 'pending';
  let pollAttempts = 0;
  const maxPollAttempts = 5; // Limit polling attempts to avoid excessively long tests

  while (jobStatus !== 'complete' && jobStatus !== 'failed' && pollAttempts < maxPollAttempts) {
    const getRes = http.get(`${BASE_URL}/jobs/${requestId}`, {
      tags: { name: 'GET /jobs/{request_id} (polling)' }
    });

    check(getRes, {
      'GET /jobs/{request_id} status is 200 or 404': (r) => r.status === 200 || r.status === 404,
      'GET /jobs/{request_id} response has status': (r) => r.json() && r.json().status !== undefined
    });

    if (getRes.status === 200 && getRes.json()) {
      jobStatus = getRes.json().status;
      if (jobStatus === 'processing') {
        sleep(0.2); // Poll more frequently if still processing
      } else {
        // Job complete or failed, break loop
        break;
      }
    } else if (getRes.status === 404) {
      // Job not found (e.g., if polling a random UUID)
      break;
    } else {
      logger.error(`Failed to get job status for ${requestId}: ${getRes.status} ${getRes.body}`);
      break;
    }
    pollAttempts++;
  }
}
